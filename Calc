use strict;
use warnings;
use IO::Handle;

STDOUT->autoflush( 1 );

#для расчета
sub _calculate {
    my ( $total, $expr ) = @_; #принимаем текущий результат и новое выражение

    #добавляем текущий общий результат к выражению, если оно начинается с оператора
    if ( $expr =~ /^\s*[-+*\/]\s*-?\d/ ) {
        $expr = $total . " " . $expr;
    }
    #разделяем выражение на числа и операторы
    my @parts = split( /\s*([-+*\/])\s*/, $expr );

    $total = shift @parts;
    while ( @parts ) {
        my $operator = shift @parts;
        my $next_num = shift @parts;

        # Выполнение операций
        if ($operator eq '+') {
            $total += $next_num;
        } elsif ( $operator eq '-' ) {
            $total -= $next_num;
        } elsif ( $operator eq '*' ) {
            $total *= $next_num;
        } elsif ( $operator eq '/' ) {
            return "Ошибка: деление на ноль" if $next_num == 0;
            $total /= $next_num;
        }
    }
    return $total;     #вывод результат операции, либо ошибка
}

#очистка прошлого вывода в зависимости от системы
sub _clear_screen {
    if ($^O eq 'MSWin32') { system("cls"); }
    else { system("clear"); }
}

my $total = 0;         #результат
my $expression = "0";  #все операции которые ввел пользователь

while ( 1 ) {
    _clear_screen();
    print "Текущий результат: $total\n";
    print "Введите операцию (или '=' для завершения): ";
    chomp( my $input = <STDIN> );

    if ( $input eq '=' ) {
        last;
    }
    
    #Проверка корректности ввода
    if ( $input !~ /^([-+*\/] \s* -?\d+(\.\d+)?(?: \s* [-+*\/] \s* -?\d+(\.\d+)?)*)$/x ) {
        print "Ошибка ввода. Попробуйте еще раз.\n";
        next;
    }

    # Выполнение расчета
    my $result = _calculate( $total, $input );
    if ( $result =~ /^Ошибка:/ ) {
        print "$result\n";
    } else {
        $input =~ s/\s+//g; # Удаление всех пробелов из ввода для красоты
        $expression .= $input;
        $total = $result;
    }
}

print "Результат: $expression = $total\n";
exit;
